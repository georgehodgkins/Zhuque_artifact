# Zhuque
Zhuque (USENIX ATC '23) is a modified version of musl libc,
plus a small modification to the Linux kernel.

## Hardware Requirements
Zhuque does not require that the evaluation machine has real persistent memory (although only real
persistent memory can fully reproduce our results). However, many of the comparison systems do require
real PMEM to run.

## Getting Started
### Docker image with Zhuque-libc
The libc portion of the artifact is packaged as a Docker image, based on Alpine Linux 3.14. 

To build, starting in the root directory:
	`docker build . -t zhuque-artifact --libc_flags=<flags>`

	There are two important options which can be specified in libc_flags:

	- `-DREAL_PMEM` selects whether Zhuque tries to mmap memory pools it creates using the `MAP_SYNC`
	flag, which is only allowed for DAX-supporting filesystems (ext4, xfs) backed by an appropriate medium. 
	Building without this flag is the "Zhuque on DRAM" configuration we report in our evaluations.

	- `-DUSE_PIGFRAME` selects whether Zhuque should try to use our kernel modification. See below for more
	information.
	
	These options are independent of each other. To select both, pass them in a string: `'-DREAL_PMEM -DUSE_PIGFRAME'`.

	A full build took around 1.5 hours on the evaluation machine described in the paper. It should require
	no interaction.

To run:
	Without a PMEM filesystem:
		`docker run --rm -it -v /path/to/tmpfs:/tmp zhuque-artifact`
	With a PMEM filesystem:
		`docker run --rm -it -v /path/to/tmpfs:/tmp -v /path/to/pmem:/mnt/pmem zhuque-artifact`	

	If you do not mount a filesystem at `/mnt/pmem`, you must create that directory within
	the container filesystem. The filesystem mounted at `/tmp` must support the `O_TMPFILE`
	flag for file creation (required by libc-bench).

	Executing `run_all.sh` in the `/` directory of the container will run all benchmarks
	and place the results in /results, in CSV format with names corresponding to figures in the paper.
	This took about 30 minutes on our machine, and should require no user interaction. Python scripts
    and instructions for reproducing the figures can be found in `/plot_scripts`.

	As noted above, Zhuque does not require real PMEM, but some of the comparison systems do. If you want
	to run only the Zhuque benchmarks, run `cd /apps && ./run_all.sh` instead. This will generate results
	named by application instead of figure, in the directory `/apps`.

	If you would like to verify that Zhuque can correctly restart applications, see the section
	on How to Use Zhuque below.

### Kernel modification
	Materials to build and test the modified kernel described in section 5.3 are in the directory
	`pigframe`. They consist of a patch and a C program to test the functionality.

	The patch is against the Ubuntu kernel tree; a link and tag at which to apply the patch are
	provided at the top of the patch file. Instructions to build (existing Ubuntu system recommended)
	can be found at <https://wiki.ubuntu.com/Kernel/BuildYourOwnKernel>. This took around 1 hour on
	our system, with no interaction required.

	Once built, the kernel can be installed from within an existing Ubuntu installation by installing
	all of the .deb packages generated by the build. Unfortunately, if you have a kernel of the same
	version (4.15.0-169) installed on the system, it will be uninstalled when you install the modified one.
	Once it is installed, it should be bootable from GRUB. 

	To test the added functionality, you can compile and run the `test_pigframe.c` program in the same
	directory as the patch. If the redundant state save area ("pigframe") is working, it should print two
	lists of identical register values. If it is run on a kernel that does not have our modifications, it
	will crash when it tries to run a nonexistent prctl operation.

	Running benchmarks on the modified kernel should be done using the Docker container, as on the unmodified
	one. Note that Zhuque will only use the pigframe if the Docker image is built with `-DUSE_PIGFRAME`.

## Detailed Instructions
### How to Use Zhuque

	Within the container, set the `LD_RELOAD` environment variable to a directory path to activate Zhuque;
	if this directory contains a valid context, the program will be restored from
	those files. Otherwise they will be created. If Zhuque was built with `-DREAL_PMEM`,
	the path must point to a DAX-supporting filesystem. Otherwise, any writable path should work. Since we 
	do not support multi-process operation, you must be careful to pass the environment variable only to the
	specific program of interest, and not, e.g., a shell script wrapped around it.

	If you append a semicolon and a floating-point number
	after the directory name in the environment variable (i.e. `LD_RELOAD=/path/to/dir;1.0`), an asynchronous
	SIGPWR will be sent to the process after that many seconds, +- a small random variance. If Zhuque is restoring
	an existing context, the signal will not be sent.
	
	To correctly restart programs, ASLR must be disabled. This requires running the Docker container with
	the --privileged flag, and invoking the program as so: `setarch -R env LD_RELOAD=<args> <program + args>`.
	See the example code in `/wsp-tests/restartit.sh` inside the container.

	Alternately, running a program in GDB will automatically disable ASLR if the container is privileged. If using
	GDB to run Zhuque programs, you should configure the GDB environment as follows:
		`set startup-with-shell off`
		`handle SIGPWR nostop`
		`handle SIGUSR2 nostop`
		`set env LD_RELOAD=/path/to/dir` (Do not pass the environment variable when starting GDB!)

### Troubleshooting
	The most common user error when running programs under Zhuque is forgetting to delete the contents of the
	context directory after a previous unclean exit of a Zhuque program using the same directory. If Zhuque
	tries to restore a different program's context in this manner, it will likely hang instead of hitting
	a hard error. Your first troubleshooting step should always be to make sure the context directory
	is empty before starting a new program.

	Other common user errors include passing a nonexistent directory in `LD_RELOAD`, or passing a path to a
	filesystem that does not support the `MAP_SYNC` flag when Zhuque was built with `-DREAL_PMEM`.

### Directory Structure
	- `musl-src`: Source code of Zhuque-musl. Most of the Zhuque implementation lives in `src/psys`.
	- `clobber-pmdk`: Modified version of Clobber-NVM artifact, provides all other comparison systems as well
		- `apps`: Contains code to build Clobber and PMDK versions of Vacation, Yada, and Memcached-1.2.5
		- `mnemosyne-gcc`: Contains code to build Mnemosyne versions of Vacation and Memcached-1.2.5
		- `atlas`: Contains code to build Atlas versions of Vacation and Yada
		- `llvm`: Contains the LLVM source code, lightly modified to build in Alpine
		- `pmdk`: Contains the PMDK source code, lightly modified to build in Alpine
		- `passes`: Contains the Clobber-NVM compiler pass
		- `*clang`: Wrapper scripts to invoke different forms of Clobber-NVM
	- `apps`: Provides the Zhuque and native versions of benchmarks
		- `cpython`: Contains the CPython source code
		- `libc-bench`: Contains the libc microbenchmarks (including the mmap ones we wrote)
		- `libmemcached`: Contains source code for the memslap Memcached benchmark (and other stuff)
		- `memcached`: Contains source code for Memcached-1.2.5
		- `memcached-1.6.17`: Contains source code for Memcached-1.6.17
		- `sneksit`: Contains the Pyperformance benchmark suite, with a handwritten test runner for Python on Zhuque
		- `stamp`: Contains source code for Yada and Vacation 
	- `pigframe`: Contains materials for the kernel modification
	- `libc-test`: Contains the musl test suite
	- `py-tests`: Contains basic functional tests for Python on Zhuque
	- `tests`: Contains basic functional tests for Zhuque
	- `taslock`: Contains a custom lock implementation used by some comparison systems
		
### Software Reference
#### Comparison systems
	- [PMDK](https://github.com/pmem/pmdk) 1.10
	- [LLVM](https://github.com/llvm/llvm-project) 7.0.0, supporting:
		- [Clobber-NVM](https://zenodo.org/record/4322233) 
		- [Atlas](https://github.com/HewlettPackard/Atlas) @ 17ef750
	- [mnemosyne-gcc](https://github.com/snalli/mnemosyne-gcc)

#### Benchmarks
	- Modified version of [libc-bench](https://www.etalabs.net/src/libc-bench/) @ b6b2ce
	- [CPython](https://github.com/python/cpython) 3.8.11
	- [PyPerformance](https://github.com/python/pyperformance) 1.0.0 + custom 'sneksit' runner
	- [Memcached](https://github.com/memcached/memcached) 1.2.5 & 1.6.17
	- [Memslap (libmemcached)](https://code.launchpad.net/libmemcached) 1.2
	- [STAMP](https://github.com/kozyraki/stamp) @ 9222e27

## Artifact Claims
	This artifact is designed to verify:
	- All performance results from Section 6, for both Zhuque and comparison systems
		(if a system with PMEM is available). The Mnemosyne implementation of Memcached
		has been having problems recently with thread counts >2.
	- Zhuque can successfully restart programs after a simulated failure,
		as described in Section 5.1
	- The kernel modification correctly saves the register file to the redundant state
		save area on kernel entry, as described in Section 5.3

	This artifact is not designed to verify:
	- The kernel modification is sufficient to protect against a failure in kernel mode
		(we cannot simulate this type of failure) 
	- The formal claims we make in Section 3 about FASE-based systems


